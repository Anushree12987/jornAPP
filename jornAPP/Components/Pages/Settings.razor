@page "/settings"
@using jornAPP.Components.Models
@using System.IO
@using Microsoft.Maui.Storage
@using System.Linq
@using jornAPP.Services
@inject ThemeService ThemeService
@inject SecurityService SecurityService
@inject EntryService EntryService
@inject PdfService PdfService
@inject JournalService JournalService

<h2>Settings ‚öôÔ∏è</h2>

<div class="settings-section">
    <h3>Theme</h3>
    <button class="btn-primary" @onclick="ToggleTheme">
        Switch to @(ThemeService.IsDark ? "Light" : "Dark") Mode
    </button>
</div>

<div class="settings-section">
    <h3>Security</h3>
    <input class="input-field" placeholder="New Password" type="password" @bind="newPassword" />
    <button class="btn-primary" @onclick="ChangePassword">Change Password</button>
    <p class="error">@securityMessage</p>
</div>

<div class="settings-section">
    <h3>Export Journal</h3>

    <label>
        <input type="checkbox" @bind="useDataRange" /> Filter by date range
    </label>

    @if (useDataRange)
    {
        <label>From:</label>
        <input class="input-field" type="date" @bind="startDate" />
        <label>To:</label>
        <input class="input-field" type="date" @bind="endDate" />
    }

    <button class="btn-primary" @onclick="ExportPdf">Export PDF</button>
    <p>@exportMessage</p>
</div>

<div class="settings-section">
    <h3>Delete Old Entries</h3>
    <button class="btn-primary" @onclick="DeleteOrphanedEntries">üóëÔ∏è Delete Old Entries</button>
    <p>@deleteMessage</p>
</div>

<style>
/* ================= SECTIONS ================= */
.settings-section {
    margin: 20px 0;
    padding: 22px;
    background-color: var(--section-bg);
    border-radius: 14px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
    transition: transform 0.25s ease, box-shadow 0.25s ease;
}

.settings-section:hover {
    transform: translateY(-2px);
    box-shadow: 0 14px 35px rgba(0, 0, 0, 0.8);
}

.settings-section h3 {
    color: var(--accent-yellow);
    margin-bottom: 14px;
    font-size: 1.25rem;
    letter-spacing: 0.5px;
}

/* ================= INPUTS ================= */
.input-field {
    width: 100%;
    padding: 13px 16px;
    margin: 10px 0;
    border-radius: 10px;
    border: 1px solid #2a2a2a;
    background-color: var(--input-bg);
    color: var(--input-text);
    font-size: 1rem;
    transition: border 0.2s ease, box-shadow 0.2s ease;
}

.input-field::placeholder {
    color: #9a9a9a;
}

.input-field:focus {
    outline: none;
    border-color: var(--accent-yellow);
    box-shadow: 0 0 0 2px rgba(255, 212, 0, 0.25);
}

.error {
    color: #ff5c5c;
    margin-top: 10px;
    font-weight: 500;
}
</style>

@code {
    string newPassword = "";
    string securityMessage = "";
    string exportMessage = "";
    bool useDataRange = false;
    DateTime startDate = DateTime.Today.AddDays(-7);
    DateTime endDate = DateTime.Today;

    void ToggleTheme()
    {
        ThemeService.ToggleTheme();
    }

    async Task ChangePassword()
    {
        if (string.IsNullOrWhiteSpace(newPassword))
        {
            securityMessage = "Password cannot be empty";
            return;
        }

        var success = await SecurityService.ChangePasswordAsync(newPassword);
        securityMessage = success ? "Password changed successfully" : "Failed to change password";
        newPassword = "";
    }

    async Task ExportPdf()
    {
        try
        {
            exportMessage = "Starting export...";
            StateHasChanged();

            var allEntries = await EntryService.GetAllEntriesForExportAsync() ?? new List<JournalEntry>();
            var entries = useDataRange
                ? allEntries.Where(e => e.EntryDate.Date >= startDate.Date && e.EntryDate.Date <= endDate.Date).ToList()
                : allEntries;

            if (!entries.Any())
            {
                exportMessage = "No entries found to export";
                return;
            }

            exportMessage = $"Generating PDF for {entries.Count} entries...";
            StateHasChanged();

            // Generate PDF as byte[]
            byte[] pdfBytes = PdfService.ExportEntriesToPdf(entries, useDataRange ? startDate : null, useDataRange ? endDate : null);

            var fileName = useDataRange
                ? $"Journal_{startDate:yyyyMMdd}_{endDate:yyyyMMdd}.pdf"
                : $"Journal_AllEntries_{DateTime.Now:yyyyMMdd}.pdf";

            // Desktop folder path
            var desktopFolder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "jornapppdf");

            if (!Directory.Exists(desktopFolder))
            {
                Directory.CreateDirectory(desktopFolder);
            }

            // Full file path
            var filePath = Path.Combine(desktopFolder, fileName);

            // Save PDF
            await File.WriteAllBytesAsync(filePath, pdfBytes);

            // Open PDF automatically
            await Launcher.OpenAsync(filePath);

            exportMessage = $"‚úÖ PDF saved and opened at: {filePath}";
        }
        catch (Exception ex)
        {
            exportMessage = $"‚ùå Export failed: {ex.Message}";
        }
    }

    string deleteMessage = "";
    async Task DeleteOrphanedEntries()
    {
        try
        {
            await EntryService.DeleteOrphanedEntriesAsync();
            deleteMessage = "‚úÖ Old entries deleted! Create new entries and they will export correctly.";
        }
        catch (Exception ex)
        {
            deleteMessage = $"‚ùå Error: {ex.Message}";
        }
    }

    protected override void OnInitialized()
    {
        ThemeService.OnThemeChanged += StateHasChanged;
    }

    public void Dispose()
    {
        ThemeService.OnThemeChanged -= StateHasChanged;
    }
}
